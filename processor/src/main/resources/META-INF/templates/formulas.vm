package $package;

import java.math.MathContext;
import java.math.RoundingMode;
import java.math.BigDecimal;

import javax.annotation.Generated;

import org.apfloat.Apfloat;
import org.apfloat.ApfloatMath;
import org.bitbucket.easymath.AbstractFormulas;
import org.bitbucket.easymath.FunctionCatalog;
import org.bitbucket.easymath.logging.ResolutionLogSupplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Generated("$generator")
@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
public class $classname extends AbstractFormulas {

	private static Logger logger = LoggerFactory.getLogger(${classname}.class);

	#foreach( $constant in ${constants} )
	  #declareConstant( $constant )
	#end

    public $classname() {
        this(new FunctionCatalog());
    }

    public $classname(FunctionCatalog catalog) {
        super(catalog);
    }
#foreach( $function in ${functions} )

#if( !${function.inputs.empty} )
    /**
     * Formula: ${function.name}=${function.formula}
     */
    public ${function.type} ${utils.uncapitalize($function.name)}( #typedArguments( "Number" ${function.inputs} )) {
        #check( $function )
        return ${utils.uncapitalize($function.name)}( #typecast( ${function} ) );
    }
#end  

    /**
     * Formula: ${function.name}=${function.formula}
     */
    public ${function.type} ${utils.uncapitalize($function.name)}( #typedArguments( ${function.type} ${function.inputs} )) {
		#if( ${function.inputs.empty} )
		  logger.trace("Entering...");
		#else
		  logger.trace("Entering with arguments: {}", new Object[] {#arguments( ${function.inputs} )});
		#end
        #check( $function )
        
        // Function precision and rounding mode definition
        MathContext mc = new MathContext(${function.precision}, RoundingMode.${function.roundingMode});
        
        // Function resolution
        logger.info("Resolution of ${function.name} = ${function.formula}");
        #foreach( $operation in ${function.operations} )
          #declareOperation( $function $operation )
        #end
        
        logger.trace("Exiting...");
        return ${function.lastOperation.id};
    }
#end
}
## ----------------------------------------------------------------------------
## arguments
## ----------------------------------------------------------------------------
#macro( arguments $inputs )
  #foreach( $input in ${inputs} )
    ${input.id}#if( ${foreach.hasNext} ), #end
  #end
#end
## ----------------------------------------------------------------------------
## typedArguments
## ----------------------------------------------------------------------------
#macro( typedArguments $type $inputs)
  #foreach( $input in ${inputs} )
    $type ${input.id}#if( ${foreach.hasNext} ), #end
  #end
#end
## ----------------------------------------------------------------------------
## resolutionArguments
## ----------------------------------------------------------------------------
#macro( resolutionArguments $inputs )
  #foreach( $input in ${inputs} )
    ${input}#if( ${foreach.hasNext} ), #end
  #end
#end
## ----------------------------------------------------------------------------
## check
## ----------------------------------------------------------------------------
#macro( check $function )
  #if( ${function.type} == "BigDecimal" || ${function.type} == "Apfloat") 
    // Method protection block
    #foreach( $input in ${function.inputs} )
      if (${input.id} == null) {
          throw new IllegalArgumentException("Argument '${input.id}' cannot be null.");
      }
    #end
  #end
#end
## ----------------------------------------------------------------------------
## typecast
## ----------------------------------------------------------------------------
#macro( typecast $function )
  #foreach( $input in ${function.inputs} )
    typecast(${input.id}, ${function.type}.class)#if( ${foreach.hasNext} ), #end
  #end
#end
## ----------------------------------------------------------------------------
## declareConstant
## ----------------------------------------------------------------------------
#macro( declareConstant $constant )
  #if( ${constant.type} == "double" )
    private static final ${constant.type} ${constant.id} = ${constant.value}D;
  #elseif( ${constant.type} == "Apfloat" )
    private static final ${constant.type} ${constant.id} = new Apfloat("${constant.value}");
  #elseif( ${constant.type} == "BigDecimal" )
    private static final ${constant.type} ${constant.id} = new BigDecimal("${constant.value}");
  #else
    Error declaring constant: Type not found!!!!
  #end
#end
## ----------------------------------------------------------------------------
## declareOperation
## ----------------------------------------------------------------------------
#macro( declareOperation $function $operation )
  #if( ${operation.class.simpleName} == "UnaryOperation" )
    #declareUnary( $operation )
  #elseif( ${operation.class.simpleName} == "BinaryOperation" )
    #declareBinary( $operation )
  #elseif( ${operation.class.simpleName} == "FunctionOperation" )
    #declareFunction( $operation )
  #else
    Operation not supported!!!!!
  #end
#end
## ----------------------------------------------------------------------------
## declareUnary
## ----------------------------------------------------------------------------
#macro( declareUnary $operation )
  #if( ${operation.type} == "double" )
    #if( ${operation.operator} == '!' )
      ${operation.type} ${operation.id} = super.fat(${operation.operand.id});
    #else
      ${operation.type} ${operation.id} = ${operation.operand.id} * (${operation.operator}1);
    #end
  #else
    #if( ${operation.operator} == '!' )
      ${operation.type} ${operation.id} = super.fat(${operation.operand.id}, mc);
    #elseif( ${operation.operator} == '-' )
      ${operation.type} ${operation.id} = ${operation.operand.id}.multiply(BigDecimal.ONE.negate(), mc);
    #else
      ${operation.type} ${operation.id} = ${operation.operand.id};
    #end
  #end  
#end
## ----------------------------------------------------------------------------
## declareBinary
## ----------------------------------------------------------------------------
#macro( declareBinary $operation )
  #if( ${operation.type} == "double" )
    #if( ${operation.operator} == '^' )
      ${operation.type} ${operation.id} = super.pow(${operation.leftOperand.id}, ${operation.rightOperand.id}, mc, ${operation.type}.class);
    #elseif( ${operation.operator} == '*' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id} * ${operation.rightOperand.id};
    #elseif( ${operation.operator} == '/' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id} / ${operation.rightOperand.id};
    #elseif( ${operation.operator} == '%' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id} % ${operation.rightOperand.id};
    #elseif( ${operation.operator} == '+' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id} + ${operation.rightOperand.id};
    #elseif( ${operation.operator} == '-' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id} - ${operation.rightOperand.id};
    #else
      Operator '${operation.operator}' not found!!!!!!
    #end
  #elseif( ${operation.type} == "Apfloat" )
    #if( ${operation.operator} == '^' )
      ${operation.type} ${operation.id} = super.pow(${operation.leftOperand.id}, ${operation.rightOperand.id}, mc, ${operation.type}.class);
    #elseif( ${operation.operator} == '*' )
      ${operation.type} ${operation.id} = ApfloatMath.round(${operation.leftOperand.id}.multiply(${operation.rightOperand.id}), mc.getPrecision(), mc.getRoundingMode());
    #elseif( ${operation.operator} == '/' )
      ${operation.type} ${operation.id} = ApfloatMath.round(${operation.leftOperand.id}.divide(${operation.rightOperand.id}), mc.getPrecision(), mc.getRoundingMode());
    #elseif( ${operation.operator} == '%' )
      ${operation.type} ${operation.id} = ApfloatMath.round(${operation.leftOperand.id}.remainder(${operation.rightOperand.id}), mc.getPrecision(), mc.getRoundingMode());
    #elseif( ${operation.operator} == '+' )
      ${operation.type} ${operation.id} = ApfloatMath.round(${operation.leftOperand.id}.add(${operation.rightOperand.id}), mc.getPrecision(), mc.getRoundingMode());
    #elseif( ${operation.operator} == '-' )
      ${operation.type} ${operation.id} = ApfloatMath.round(${operation.leftOperand.id}.subtract(${operation.rightOperand.id}), mc.getPrecision(), mc.getRoundingMode());
    #else
      Operator '${operation.operator}' not found!!!!!!
    #end
  #elseif( ${operation.type} == "BigDecimal" )
    #if( ${operation.operator} == '^' )
      ${operation.type} ${operation.id} = super.pow(${operation.leftOperand.id}, ${operation.rightOperand.id}, mc, ${operation.type}.class);
    #elseif( ${operation.operator} == '*' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id}.multiply(${operation.rightOperand.id}, mc);
    #elseif( ${operation.operator} == '/' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id}.divide(${operation.rightOperand.id}, mc);
    #elseif( ${operation.operator} == '%' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id}.remainder(${operation.rightOperand.id}, mc);
    #elseif( ${operation.operator} == '+' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id}.add(${operation.rightOperand.id}, mc);
    #elseif( ${operation.operator} == '-' )
      ${operation.type} ${operation.id} = ${operation.leftOperand.id}.subtract(${operation.rightOperand.id}, mc);
    #else
      Operator '${operation.operator}' not found!!!!!!
    #end
  #end
#end
## ----------------------------------------------------------------------------
## declareFunction
## ----------------------------------------------------------------------------
#macro( declareFunction $operation )
  #if( ${operation.type} == "double" )
    ${operation.type} ${operation.id} = super.compute("${operation.name}", #arguments( ${operation.operands} ));
  #else
    ${operation.type} ${operation.id} = super.compute("${operation.name}", mc, #arguments( ${operation.operands} ));
  #end
#end
